---
// DecisionNode.astro - Decision node component for the flowchart
import BaseNode from './BaseNode.astro';

// Props
interface Props {
  data?: {
    id?: string;
    label?: string;
    description?: string;
    optional?: boolean;
    required?: boolean;
    selectedOption?: string;
    options?: string[];
    prerequisites?: string[];
    unlocks?: string[];
    onComplete?: (id: string, option: string, isChanging: boolean) => void;
    onRemove?: (id: string) => void;
  };
  isConnectable?: boolean;
}

// Default props
const { data = {}, isConnectable = true } = Astro.props;

// Determine if this is an optional node
const isOptional = data.optional === true;

// Background color based on type and completion status
const getBgColor = () => {
  if (data.selectedOption) return 'var(--completedNode)'; // Completed
  if (isOptional) return 'var(--optionalNode)'; // Optional
  return 'var(--requiredNode)'; // Required
};

// Border color based on type and completion status
const getBorderColor = () => {
  if (data.selectedOption) return 'var(--completedBorder)'; // Completed
  if (isOptional) return 'var(--optionalBorder)'; // Optional
  return 'var(--requiredBorder)'; // Required
};

// Determine if the remove button should be shown
const showRemoveButton = isOptional || !data.selectedOption;
---

<BaseNode
  data={data}
  isConnectable={isConnectable}
  className={`decision-node ${data.selectedOption ? 'completed' : ''} ${
    isOptional ? 'optional' : 'required'
  }`}
  style={{
    padding: '15px',
    borderRadius: '8px',
    background: getBgColor(),
    border: `2px solid ${getBorderColor()}`,
    width: '220px',
    boxShadow: '0 4px 6px var(--boxShadow)',
  }}
  showRemoveButton={showRemoveButton}
  isExpandable={true}
  showBadges={true}
  nodeType="decision"
>
  <!-- Decision node content -->
  <div id={`decision-content-${data.id}`} class="decision-content">
    <!-- Decision change warning (initially hidden) -->
    <div
      class="decision-warning"
      style={{
        backgroundColor: 'var(--warningBackground)',
        color: 'var(--warningText)',
        padding: '10px',
        borderRadius: '6px',
        marginBottom: '10px',
        fontSize: '0.85rem',
        border: '1px solid var(--warningBorder)',
        display: 'none',
      }}
    >
      <strong>Warning:</strong> Changing this decision may remove connected nodes.
      <div
        style={{
          marginTop: '8px',
          display: 'flex',
          justifyContent: 'space-between',
        }}
      >
        <button
          class="cancel-change-button"
          style={{
            padding: '4px 8px',
            backgroundColor: 'var(--buttonBackground)',
            border: '1px solid var(--buttonBorder)',
            borderRadius: '4px',
            cursor: 'pointer',
          }}
        >
          Cancel
        </button>
        <button
          class="confirm-change-button"
          style={{
            padding: '4px 8px',
            backgroundColor: 'var(--red)',
            color: 'var(--badgeText)',
            border: '1px solid var(--red)',
            borderRadius: '4px',
            cursor: 'pointer',
          }}
        >
          Change Decision
        </button>
      </div>
    </div>

    <!-- Options section -->
    {data.options && data.options.length > 0 && (
      <div
        class="node-options"
        style={{
          fontSize: '0.9rem',
          background: 'var(--nodeOptionsBackground)',
          borderRadius: '6px',
          padding: '8px 10px',
          marginTop: '10px',
          display: data.selectedOption ? 'none' : 'block',
        }}
      >
        <div style={{ fontWeight: 'bold', marginBottom: '5px' }}>
          Choose an option:
        </div>
        {data.options.map((option, index) => (
          <div
            class="option-item"
            data-option={option}
            style={{
              cursor: 'pointer',
              padding: '5px 8px',
              margin: '3px 0',
              borderRadius: '4px',
              transition: 'all 0.2s ease',
              backgroundColor: 'var(--nodeOptionBackground)',
              border: '1px solid transparent',
            }}
          >
            {option}
          </div>
        ))}
      </div>
    )}

    <!-- Selected option display -->
    {data.selectedOption && (
      <div
        class="selected-option"
        style={{
          fontSize: '0.9rem',
          marginTop: '8px',
          padding: '8px',
          background: 'var(--selectedOptionBackground)',
          borderRadius: '6px',
          border: '1px dashed var(--green)',
          display: 'block',
        }}
      >
        <strong>You chose:</strong> {data.selectedOption}
        <!-- Change decision button -->
        <button
          class="change-decision-button"
          style={{
            display: 'block',
            marginTop: '8px',
            padding: '4px 8px',
            backgroundColor: 'var(--buttonBackground)',
            border: '1px solid var(--buttonBorder)',
            borderRadius: '4px',
            fontSize: '0.75rem',
            cursor: 'pointer',
            width: '100%',
          }}
        >
          Change Decision
        </button>
      </div>
    )}
  </div>
</BaseNode>

<script define:vars={{ nodeId: data.id, initialSelectedOption: data.selectedOption, isOptional }}>
  // Client-side code to handle decision node functionality

  // State
  let selectedOption = initialSelectedOption;
  let isChangingDecision = false;

  // Function to initialize the node
  function initializeNode() {
    const nodeContent = document.getElementById(`decision-content-${nodeId}`);
    if (!nodeContent) return;

    // Get elements
    const warningEl = nodeContent.querySelector('.decision-warning');
    const optionsEl = nodeContent.querySelector('.node-options');
    const selectedOptionEl = nodeContent.querySelector('.selected-option');
    const changeDecisionBtn = nodeContent.querySelector('.change-decision-button');
    const cancelChangeBtn = nodeContent.querySelector('.cancel-change-button');
    const confirmChangeBtn = nodeContent.querySelector('.confirm-change-button');
    const optionItems = nodeContent.querySelectorAll('.option-item');

    // Set up option click handlers
    optionItems.forEach(item => {
      item.addEventListener('mouseenter', () => {
        item.style.backgroundColor = 'var(--nodeOptionHoverBackground)';
        item.style.border = isOptional
          ? '1px solid var(--optionalBorder)'
          : '1px solid var(--requiredBorder)';
      });

      item.addEventListener('mouseleave', () => {
        item.style.backgroundColor = 'var(--nodeOptionBackground)';
        item.style.border = '1px solid transparent';
      });

      item.addEventListener('click', () => {
        const option = item.getAttribute('data-option');
        handleOptionSelect(option);
      });
    });

    // Set up change decision button
    if (changeDecisionBtn) {
      changeDecisionBtn.addEventListener('click', () => {
        isChangingDecision = true;
        updateUI();
      });
    }

    // Set up cancel change button
    if (cancelChangeBtn) {
      cancelChangeBtn.addEventListener('click', () => {
        isChangingDecision = false;
        updateUI();
      });
    }

    // Set up confirm change button
    if (confirmChangeBtn) {
      confirmChangeBtn.addEventListener('click', () => {
        selectedOption = null;
        isChangingDecision = false;
        updateUI();

        // Dispatch event for option change
        const changeEvent = new CustomEvent('decisionOptionChange', {
          detail: { nodeId, option: null, isChanging: true }
        });
        document.dispatchEvent(changeEvent);
      });
    }

    // Initial UI update
    updateUI();
  }

  // Function to handle option selection
  function handleOptionSelect(option) {
    // If changing a decision, first confirm
    if (selectedOption && !isChangingDecision) {
      isChangingDecision = true;
      updateUI();
      return;
    }

    // Reset the changing state
    isChangingDecision = false;

    // Set the new option
    selectedOption = option;

    // Update UI
    updateUI();

    // Dispatch event for option change
    const changeEvent = new CustomEvent('decisionOptionChange', {
      detail: { nodeId, option, isChanging: selectedOption !== null }
    });
    document.dispatchEvent(changeEvent);
  }

  // Function to update UI based on state
  function updateUI() {
    const nodeContent = document.getElementById(`decision-content-${nodeId}`);
    if (!nodeContent) return;

    // Get elements
    const warningEl = nodeContent.querySelector('.decision-warning');
    const optionsEl = nodeContent.querySelector('.node-options');
    const selectedOptionEl = nodeContent.querySelector('.selected-option');

    // Update warning visibility
    if (warningEl) {
      warningEl.style.display = isChangingDecision ? 'block' : 'none';
    }

    // Update options visibility
    if (optionsEl) {
      optionsEl.style.display = (!selectedOption || isChangingDecision) ? 'block' : 'none';

      // Update options title
      const optionsTitle = optionsEl.querySelector('div');
      if (optionsTitle) {
        optionsTitle.textContent = isChangingDecision ? 'Select new option:' : 'Choose an option:';
      }
    }

    // Update selected option visibility
    if (selectedOptionEl) {
      selectedOptionEl.style.display = (selectedOption && !isChangingDecision) ? 'block' : 'none';

      // Update selected option text
      const optionText = selectedOptionEl.childNodes[1];
      if (optionText && selectedOption) {
        optionText.textContent = ` ${selectedOption}`;
      }
    }

    // Update node appearance
    updateNodeAppearance();
  }

  // Function to update node appearance based on selection state
  function updateNodeAppearance() {
    const node = document.getElementById(`node-${nodeId}`);
    if (!node) return;

    // Update background and border colors
    let bgColor, borderColor;

    if (selectedOption) {
      bgColor = 'var(--completedNode)';
      borderColor = 'var(--completedBorder)';
      node.classList.add('completed');
    } else {
      if (isOptional) {
        bgColor = 'var(--optionalNode)';
        borderColor = 'var(--optionalBorder)';
        node.classList.remove('completed');
        node.classList.add('optional');
      } else {
        bgColor = 'var(--requiredNode)';
        borderColor = 'var(--requiredBorder)';
        node.classList.remove('completed');
        node.classList.add('required');
      }
    }

    // Apply styles
    node.style.background = bgColor;
    node.style.border = `2px solid ${borderColor}`;
  }

  // Initialize when DOM is loaded
  document.addEventListener('DOMContentLoaded', initializeNode);

  // Re-initialize when React Flow updates the DOM
  document.addEventListener('reactFlowNodeAdded', initializeNode);
</script>

<style>
  .decision-content {
    position: relative;
  }

  .option-item {
    transition: all 0.2s ease;
  }

  .option-item:hover {
    transform: translateX(2px);
  }
</style>
